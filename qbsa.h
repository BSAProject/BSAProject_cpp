#ifndef QBSA_H
#define QBSA_H

#include <QString>

const double  coeff_from_Tutc_to_Tstar = 1.0027379093507937;

class qheaderBSA
{
public:
   unsigned int numpar; // Количество строк в заголовке, включая первую строку
   QString source; // Содержание определяется наблюдателем
   QString alpha; // Содержание определяется наблюдателем
   QString delta; // Содержание определяется наблюдателем
   float fcentral; // Центральная частота общей полосы приема в Мгц
   float wb_total; // Ширина полосы приема в МГц
   QString date_begin; // Дата начала регистрации
   QString time_begin; // Время начала регистрации
   QString date_end; // Дата конца регистрации
   QString time_end; // Время конца регистрации
   std::vector<int> modulus; // Перечень  активных модулей
   unsigned int nCountPoint;
      // -  количество значений в одной временнОй точке!
      // - оно равно произведению числа лучей на (число частот +1)
   float tresolution; // Временное разрешение в мс
   unsigned int npoints; // Количество зарегистрированных точек
   unsigned int nbands; // Количество полос, на которые разбивается общая полоса приема
   std::vector<float> wbands; // Ширина в МГц каждой полосы
   std::vector<float> fbands; // Центральная частота приема каждой полосы в МГц

   void clear()
   {
       modulus.clear();
       wbands.clear();
       fbands.clear();
   }
};

class qbsa
{
public:

    QString name_file_of_datas; // полное имя файла (с директорией, где лежит файл)
    unsigned int nCanal = 8; // количество лучей в модуле - на уровне жедеза, не меняется, =8
    unsigned int sizeHeader; // размер в байтах символьной шапки файла


    // соответствие каналов

    const float dec[12][8] = {
            {42.13,41.72,41.31,40.89,40.47,40.06,39.64,39.23},
            {38.79,38.38,37.95,37.54,37.11,36.69,36.26,35.85},
            {35.40,34.97,34.54,34.12,33.69,33.25,32.82,32.38},
            {31.94,31.50,31.06,30.61,30.17,29.73,29.29,28.84},
            {28.37,27.92,27.47,27.01,26.56,26.10,25.64,25.18},
            {24.70,24.23,23.76,23.29,22.81,22.34,21.86,21.38},

            {20.83,20.39,19.89,19.41,18.91,18.41,17.91,17.40},
            {16.87,16.36,15.84,15.32,14.80,14.27,13.74,13.20},
            {12.63,12.10,11.54,10.98,10.42,9.85,9.28,8.70},
            {8.09,7.50,6.90,6.29,5.68,5.05,4.42,3.78},
            {3.11,2.45,1.79,1.11,0.42,-0.28,-1.00,-1.72},
            {-2.50,-3.25,-4.02,-4.82,-5.62,-6.46,-7.32,-8.20}
        };


    /*
    const float dec[12][8] = {
            {42.13,41.72,41.31,40.89,40.47,40.06,39.64,39.23},
            {38.79,38.38,37.95,37.54,37.11,37.69,36.26,35.85},
            {35.40,34.97,34.54,34.12,33.69,33.25,32.82,32.38},
            {31.94,31.50,31.06,30.61,30.17,29.73,29.29,28.84},
            {28.37,27.92,27.47,27.01,26.56,26.10,25.64,25.18},
            {24.70,24.23,23.76,23.29,22.81,22.34,21.86,21.38},
            {-8.20,-7.32,-6.46,-5.62,-4.82,-4.02,-3.25,-2.50},
            {-1.72,-1.00,-0.28,0.42,1.11,1.79,2.45,3.11},
            {3.78,4.42,5.05,5.68,6.29,6.90,7.50,8.09},
            {8.70,9.28,9.85,10.42,10.98,11.54,12.10,12.63},
            {13.20,13.74,14.27,14.80,15.32,15.84,16.36,16.87},
            {17.40,17.91,18.41,18.91,19.41,19.89,20.39,20.83}
        };

    */

    qheaderBSA header; //  шапка
    std::vector<float> data_file; // данные

    void clear()
    {
        data_file.clear();
        header.clear();
    }
};

class starTime
{
public:
    int hour;
    int minute;
    double second;

    starTime(int Year = 2000, int Month = 1, int Date = 1, int hr = 0, int min = 0, double sec = 0,
             double longitude_in_h = 2.50875326667, int d_h_from_UT = -4)
    {

    // номер дня в месяце, номер месяца (январь=1), номер года

    int im = Month;
    int iday = Date;
    int iyear = Year;

    int r = 1296000.0; // 360.*3600.

    int month[12] = {31,28,31,30,31,30,31,31,30,31,30,31};



    int i;
    //integer
    double t,sm,p,e,q,d,f,m,l,pl,ps,s0;
    // : real;
    //{*--------------------------------------------------------------------*
    //*                        Calculate iday and t                        *
    //*--------------------------------------------------------------------*}

    if (im != 1)
    {
        if (iyear % 400 == 0 || (iyear % 100 != 0 && iyear % 4 == 0))
            month[1] = 29;

        for (i=1; i<=im-1; i++)
            iday += month[i-1];
    }

    double iy = iyear - 1900;
    //--- iday = (iday-1)+(iy-1) div 4;
    iday = floor((iday-1)+(iy-1)/4);

    //--t := Longint(iday) + Longint(iy)*365.0;
    t=iday + iy*365.0;
    t = (t+0.5)/36525.0;   // {   ! 00.01.1900 12h UT}
    t = t - 1;    // {   ! 01.01.2000 12h UT1}

    //{*--------------------------------------------------------------------*
    //*                    Calculate mean sidereal time                    *
    //*--------------------------------------------------------------------*}
    sm = 24110.548410 + 8640184.8128660*t + 0.093104*t*t- 0.00000620*t*t*t;
    while (sm <= 0)
        sm = sm + 86400.0;
    while (sm > 86400)
        sm = sm - 86400.0;
    //{*--------------------------------------------------------------------*
    //*             Calculate long and short periodic nutation             *
    //*--------------------------------------------------------------------*}
    //70-ja stroka
    p = M_PI/180.0/3600.0;
    //{-------------------}
    e = p*(84381.448 - 46.8150*t - 0.00059*t*t + 0.0018130*t*t*t);
    //{-------------------}
    q = p*( 450160.280 -   5.0*r*t - 482890.539*t+ 7.455*t*t + 0.0080*t*t*t);
    d = p*(1072261.3070 + 1236.0*r*t + 1105601.328*t - 6.891*t*t+ 0.0190*t*t*t);
    f = p*( 335778.8770 + 1342.0*r*t + 295263.1370*t - 13.2570*t*t+ 0.0110*t*t*t);
    m = p*(1287099.804 +  99.0*r*t+1292581.2240*t -  0.5770*t*t - 0.0120*t*t*t);
    l = p*( 485866.7330+1325.0*r*t + 715922.633*t + 31.3100*t*t+ 0.0640*t*t*t);
    //80-ja stroka{*-------------------}

    pl =  -(17.19960 + 0.017420*t)*sin(q);

    //pl=sin(q);
    pl = pl + (0.20620 + 0.000020*t)*sin(2.0*q);
    pl = pl +   0.00460            *sin(q+2.0*f-2.0*l);
    pl = pl +   0.00110            *sin(2.0*(l-f));
    pl = pl -   0.00030            *sin(2.0*(q+f-l));
    pl = pl-   0.00030            * sin (l-m-d);
    pl = pl-   0.00020            * sin (q-2.0*d+2.0*f-2.0*m);
    pl = pl+   0.00010            * sin (q-2.0*f+2.0*l);
    pl = pl-( 1.31870+ 0.000160*t)* sin (2.0*(q-d+f));
    pl = pl+(  0.14260-0.000340*t)* sin (m);
    pl = pl-(  0.05170-0.000120*t)* sin (2.0*q-2.0*d+2.0*f+m);
    pl = pl+(  0.02170-0.000050*t)* sin (2.0*q-2.0*d+2.0*f-m);
    pl = pl+(  0.01290+0.000010*t)* sin (q-2.0*d+2.0*f);
    pl = pl+   0.00480            * sin (2.0*(l-d));
    pl = pl-   0.00220            * sin (2.0*(f-d));
    pl = pl+(  0.00170-0.000010*t)* sin (2.0*m);
    pl = pl-   0.00150            * sin (q+m);
    pl = pl-(  0.00160-0.000010*t)* sin (2.0*(q-d+f+m));
    pl = pl-   0.00120            * sin (q-m);
    pl = pl-   0.00060            * sin (q+2.0*d-2.0*l);
    pl = pl-   0.00050            * sin (q-2.0*d+2.0*f-m);
    pl = pl+   0.00040            * sin (q-2.0*d+2.0*l);
    pl = pl+   0.00040            * sin (q-2.0*d+2.0*f+m);
    pl = pl-   0.00040            * sin (l-d);
    pl = pl+   0.00010            * sin (2.0*l+m-2.0*d);
    pl = pl+   0.00010            * sin (q+2.0*d-2.0*f);
    pl = pl-   0.00010            * sin (2.0*d-2.0*f+m);
    pl = pl+   0.00010            * sin (2.0*q+m);
    pl = pl+   0.00010            * sin (q+d-l);
    pl = pl-   0.00010            * sin (m+2.0*f-2.0*d);
    //111-ja stroka{*------------------- }
    ps =   -(  0.22740+0.000020*t)* sin (2.0*(q+f));
    ps = ps+(  0.07120+0.000010*t)* sin (l);
    ps = ps-(  0.03860+0.000040*t)* sin (q+2.0*f);
    ps = ps-   0.03010            * sin (2.0*q+2.0*f+l);
    ps = ps-   0.01580            * sin (l-2.0*d);
    ps = ps+   0.01230            * sin (2.0*q+2.0*f-l);
    ps = ps+   0.00630            * sin (2.0*d);
    ps = ps+(  0.00630+0.000010*t)* sin (q+l);
    ps = ps-(  0.00580+0.000010*t)* sin (q-l);
    ps = ps-   0.00590            * sin (2.0*q+2.0*d+2.0*f-l);
    ps = ps-   0.00510            * sin (q+2.0*f+l);
    ps = ps-   0.00380            * sin (2.0*(q+d+f));
    ps = ps+   0.00290            * sin (2.0*l);
    ps = ps+   0.00290            * sin (2.0*q-2.0*d+2.0*f+l);
    ps = ps-   0.00310            * sin (2.0*(q+f+l));
    ps = ps+   0.00260            * sin (2.0*f);
    ps = ps+   0.00210            * sin (q+2.0*f-l);
    ps = ps+   0.00160            * sin (q+2.0*d-l);
    ps = ps-   0.00130            * sin (q-2.0*d+l);
    ps = ps-   0.00100            * sin (q+2.0*d+2.0*f-l);
    ps = ps-   0.00070            * sin (l+m-2.0*d);
    ps = ps+   0.00070            * sin (2.0*q+2.0*f+m);
    ps = ps-   0.00070            * sin (2.0*q+2.0*f-m);
    ps = ps-   0.00080            * sin (2.0*q+2.0*d+2.0*f+l);
    ps = ps+   0.00060            * sin (2.0*d+l);
    ps = ps+   0.00060            * sin (2.0*(q-d+f+l));
    ps = ps-   0.00060            * sin (q+2.0*d);
    ps = ps-   0.00070            * sin (q+2.0*d+2.0*f);
    ps = ps+   0.00060            * sin (q-2.0*d+2.0*f+l);
    ps = ps-   0.00050            * sin (q-2.0*d);
    ps = ps+   0.00050            * sin (l-m);
    ps = ps-   0.00050            * sin (q+2.0*f+2.0*l);
    ps = ps-   0.00040            * sin (m-2.0*d);
    ps = ps+   0.00040            * sin (l-2.0*f);
    ps = ps-   0.00040            * sin (d);
    ps = ps-   0.00030            * sin (l+m);
    ps = ps+   0.00030            * sin (l+2.0*f);
    ps = ps-   0.00030            * sin (2.0*q+2.0*f-m+l);
    ps = ps-   0.00030            * sin (2.0*q+2.0*d+2.0*f-m-l);
    ps = ps-   0.00020            * sin (q-2.0*l);
    ps = ps-   0.00030            * sin (2.0*q+2.0*f+3.0*l);
    ps = ps-   0.00030            * sin (2.0*q+2.0*d+2.0*f-m);
    ps = ps+   0.00020            * sin (2.0*q+2.0*f+m+l);
    ps = ps-   0.00020            * sin (q-2.0*d+2.0*f-l);
    ps = ps+   0.00020            * sin (q+2.0*l);
    ps = ps-   0.00020            * sin (2.0*q+l);
    ps = ps+   0.00020            * sin (3.0*l);
    ps = ps+   0.00020            * sin (2.0*q+d+2.0*f);
    ps = ps+   0.00010            * sin (2.0*q-l);
    ps = ps-   0.00010            * sin (l-4.0*d);
    ps = ps+   0.00010            * sin (2.0*(q+d+f-l));
    ps = ps-   0.00020            * sin (2.0*q+4.0*d+2.0*f-l);
    ps = ps-   0.00010            * sin (2.0*l-4.0*d);
    ps = ps+   0.00010            * sin (2.0*q-2.0*d+2.0*f+m+l);
    ps = ps-   0.00010            * sin (q+2.0*d+2.0*f+l);
    ps = ps-   0.00010            * sin (2.0*q+4.0*d+2.0*f-2.0*l);
    ps = ps+   0.00010            * sin (2.0*q+4.0*f-l);
    ps = ps+   0.00010            * sin (l-m-2.0*d);
    ps = ps+   0.00010            * sin (q-2.0*d+2.0*f+2.0*l);
    ps = ps-   0.00010            * sin (2.0*(q+d+f+l));
    ps = ps-   0.00010            * sin (q+2.0*d+l);
    ps = ps+   0.00010            * sin (2.0*q-2.0*d+4.0*f);
    ps = ps+   0.00010            * sin (2.0*q-2.0*d+2.0*f+3.0*l);
    ps = ps-   0.00010            * sin (l+2.0*f-2.0*d);
    ps = ps+   0.00010            * sin (q+2.0*f+m);
    ps = ps+   0.00010            * sin (q+2.0*d-m-l);
    ps = ps-   0.00010            * sin (q-2.0*f);
    ps = ps-   0.00010            * sin (2.0*q-d+2.0*f);
    ps = ps-   0.00010            * sin (2.0*d+m);
    ps = ps-   0.00010            * sin (l-2.0*f-2.0*d);
    ps = ps-   0.00010            * sin (q+2.0*f-m);
    ps = ps-   0.00010            * sin (q-2.0*d+m+l);
    ps = ps-   0.00010            * sin (l-2.0*f+2.0*d);
    ps = ps+   0.00010            * sin (2.0*(l+d));
    ps = ps-   0.00010            * sin (2.0*q+4.0*d+2.0*f);
    ps = ps+   0.00010            * sin (d+m);

    s0 = sm+(pl+ps)/15.0* cos (e);

    // звездное время
    hour = floor(s0/3600);
    minute = floor((s0-hour*3600)/60);
    second = floor((s0-hour*3600-minute*60)*10000)/10000;


    // определение звездного времени с учётом широты
    double Star_in_real_H, s;

    s = s0/3600 + longitude_in_h + (hr + double(min)/60 + sec/3600 + d_h_from_UT)*1.0027379093507937;

    while (s < 0)
        s = s + 24;
    while (s > 24)
        s = s - 24;

    Star_in_real_H = s;
    hour = floor(Star_in_real_H);//ceil округляет ВВЕРХ до  ближайшего целого, а вот floor - ВНИЗ, и де-факто равно div из Паскаля

    double tmp_dat = (Star_in_real_H-hour)*60;
    minute = floor(tmp_dat);
    second = (tmp_dat-minute)*60;
    };
};


#endif // QBSA_H
